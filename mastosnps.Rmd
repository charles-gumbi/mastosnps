---
title: "Detection of the signal of selection from Mastomys natalensis  in various landuse types "
output: html_notebook
---
## Setting tthe seed for reproducibility 
```{r setting seed}
#rm(list = ls())
set.seed(100)
```

## Installing packages 
```{r}
#BiocManager::install("dartR", dependencies = T)
#devtools::install_github("whitlock/OutFLANK")
#if(!requireNamespace("fields", quietly = TRUE)) install.packages("fields", repos='http://cran.us.r-project.org')
#if(!requireNamespace("LEA", quietly = TRUE)) {  
  #if (!requireNamespace("BiocManager", quietly = TRUE))
    #install.packages("BiocManager")
  #BiocManager::install("LEA")

install.packages("devtools")
library(devtools)
install.packages("BiocManager")
BiocManager::install(c("SNPRelate", "qvalue"))
install_github("green-striped-gecko/dartR")
library(dartR)
```

## Loading libaries 
```{r loading packages, message=FALSE, warning=FALSE}
library(adegenet)
library(vcfR)
library(RColorBrewer)
library(ggplot2)
library(reshape)
library(hierfstat)
library(tidyverse)
library(dplyr)
library(devtools)
library(qvalue)
library(OutFLANK)
library(pcadapt)
library(gstudio)
library(LandGenCourse)
library(tibble)
library(here)
library(pinfsc50)
library(utils)
library(LEA)
library(fields)
library(admisc)
library(vegan)
library(lfmm)
library(LEA)
library(GeNetIt)
library(EcoGenetics)
library(dartR)
library(spdep)
library(adehabitatLT)

```

## Defining plotting palletes 
```{r defining plotting  pallets, fig.height=8, fig.width=10}
pop_pallete <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
landuse_pallete <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442")
#pie(rep(1, 4), col = landuse_pallete)
```

## Reading in the SNPs  vcf file 
### pop filtered with -r=0.5 -R=0.5 
```{r pop filter -r 0.5 -R 0.5}
pop0505_data <- read.table("~/Documents/Phd_dissetation/Mastomys_SNPs/Stacks_output/pop_filter0_5/pop0505.txt",  sep = "\t", header = T)
mastoVCF0505 <- read.vcfR("~/Documents/Phd_dissetation/Mastomys_SNPs/Stacks_output/pop_filter0_5/populations.snps.vcf", convertNA = T)
#all(colnames(mastoVCF0505@gt)[-1] == pop0505_data$sample_id)
```

### pop filtered with -r=0.3 -R=0.3 
```{r pop  filter -r 0.3 -R 0.3}
#mastoVCF0303 <- read.vcfR("~/Documents/Phd_dissetation/Mastomys_SNPs/Stacks_output/pop_filter0_3_0_3/populations.snps.vcf", convertNA = T)
```

### pop filtered with -r=0.3 -R=0.5
```{r pop filtered with -r=0.3 -R=0.5}
pop0305_data <- read.table("~/Documents/Phd_dissetation/Mastomys_SNPs/Stacks_output/pop_filter0_3/pop0305.txt",  sep = "\t", header = T)
mastoVCF0305 <- read.vcfR("~/Documents/Phd_dissetation/Mastomys_SNPs/Stacks_output/pop_filter0_3/populations.snps.vcf", convertNA = T)
```
## Checking information on vcf object 
```{r checking information, fig.height=8, fig.width=10}
queryMETA(mastoVCF0305)
head(getFIX(mastoVCF0305)) 
##misssing data 
gt_vcf0305 <- extract.gt(mastoVCF0305, element = "GT", as.numeric = TRUE)
gt_vcf0305[c(2,6,18), 1:3]

## quantify missingness, all samples
missing_data <- apply(gt_vcf0305, MARGIN = 2, function(x){ sum(is.na(x)) }) #lists number of missing loci for each samples
missing_data <- missing_data/nrow(gt_vcf0305)
missing_data

## plot the above values
par(mar = c(5,4,4,2))
barplot(missing_data, las = 2, col = 1:91) +
  title(ylab = "Missingness (%)")
## heatmap
masto0305_dp <- extract.gt(mastoVCF0305, element = "DP", as.numeric=TRUE)
heatmap.bp(masto0305_dp[1:1000,], cbarplot = T, rbarplot = T, rlabels = F, clabels = T)
```

## Coverting VCF to genlight object 
```{r vcf to genlight}
mastogenlight0305 <- vcfR2genlight(mastoVCF0305)
pop(mastogenlight0305) <- pop0305_data$pop # define populations
#I am  required to specify the diploid of the organism in order to calculate some population genetic metrics
ploidy(mastogenlight0305) <- 2 # our organism is diploid
mastogenlight0305 #misssing data

mastogenlight_df <- as.data.frame(mastogenlight0305)
head(mastogenlight_df)

mastogenlight_df <-tibble::rownames_to_column(mastogenlight_df, "sample_id") 
new_mastogenlight_df <- merge(mastogenlight_df, pop0305_data, by = "sample_id")
head(new_mastogenlight_df)
```

## Subsetting genotypes  and filtering NAs 
```{r subsetting}
genotypes <- mastogenlight_df[, 2:ncol(mastogenlight_df)]
dim(genotypes)
sum(is.na(genotypes))
#1847937  NAs

#filtering out Nas
genotypes_imp <- apply(genotypes, 2, function(x) replace(x, is.na(x), as.numeric(names(which.max(table(x))))))
sum(is.na(genotypes_imp)) 
#0 NAs

#sanity check 
dim(genotypes_imp)
dim(new_mastogenlight_df)
```

## Coverting VCF to genind object 
```{r vcf to genind }
# Convert data set to genlight object
mastogenind0305 <- vcfR2genind(mastoVCF0305)
pop(mastogenind0305) <- new_mastogenlight_df$pop[-1]
popNames(mastogenind0305)
#"Elangeni"  "Shewula"   "Matsapha"  "Siteki"    "Malandela" "Tabankulu"

## file 0505 with 170 individu
mastogenind0505 <- vcfR2genind(mastoVCF0505)
mastogenind0505_df <- genind2df(mastogenind0505, usepop = TRUE)
mastogenind0505_df <- tibble::rownames_to_column(mastogenind0505_df, "sample_id") 
new_mastogenind0505_df <-merge(mastogenind0505_df, pop0505_data, by = "sample_id")
pop(mastogenind0505) <- new_mastogenind0505_df$pop
popNames(mastogenind0505)
##[1] "Elangeni"  "Shewula"   "Tabankulu" "Matsapha"  "Siteki"    "Malandela"
```

## Genetic Diversity
Before any genetic analysis, I perform a basic population genetic analysis of the genetic data, in order to better understand the nature and quality of the data and to check for underlying assumptions of population genetic models and corresponding methods.

### checking that markers are polymorphic
The genetic resolution depends on the number of markers and their polymorphism. The table above and the summary function for genind objects together provide this information. Now we run the summary function:
```{r checking polymohpism}
summary(mastogenind0305)
```

### check fo deviation from HWE
For a very large population (no drift) with random mating and non-overlapping generations (plus a few more assumptions about the mating system), and in the absence of mutation, migration (gene flow) and selection, we can predict offspring genotype frequencies from allele frequencies of the parent generation (Hardy-Weinberg equilibrium). In general, I don’t expect all of these assumptions to be met (e.g., if we want to study gene flow or selection, we kind of expect that these processes are present). Note: plants often show higher levels of departure from HWE than animals.
```{r HWE}
# Chi-squared test: p-value
HWE.test <- data.frame(sapply(seppop(mastogenind0305), 
                              function(ls) pegas::hw.test(ls, B=1000)[,3]))
HWE.test.chisq <- t(data.matrix(HWE.test))
{cat("Chi-squared test (p-values):", "\n")
round(HWE.test.chisq,3)}
#To summarize, I calculated for each locus, the proportion of populations where it was out of HWE. Here I  used conservative cut-off of alpha = 0.05 for each test. There are various ways of modifying this, including a simple Bonferroni correction, where we divide alpha by the number of tests, which you can activate here by removing the ## i. front of the line.
#Here i am  writing  the results into a data frame ‘prop_loci_out_of_HWE’ and use ‘=’ to specify the name for each column.
alpha=0.05
prop_loci_out_of_HWE <- data.frame(Chisq=apply(HWE.test.chisq< alpha, 2, mean), 
           MC=apply(HWE.test.chisq<alpha, 2, mean))
prop_loci_out_of_HWE             # Type this line again to see results table

#Here i perfomed the ‘false discovery rate’ correction for the number of test using the function ‘p.adjust’ with the argument ‘method=“fdr”’ to adjust the p-values from the previous tests. This returns a vector of with leength quals to the the number of p-values used), which I convert back into a matrix of equal to the umber of populations  rows (pops) by columns (loci). Then we procede as above.
#chisq_fdr <- matrix(p.adjust(HWE.test.chisq,method="fdr"), 
                    #nrow=nrow(HWE.test.chisq))
mc_fdr <- matrix(p.adjust(HWE.test.chisq, method="fdr"), 
                    nrow=nrow(HWE.test.chisq))

prop_loci_out_of_HWE_fdr <- data.frame(Chisq=apply(HWE.test.chisq<alpha, 1, mean), 
           MC=apply(HWE.test.chisq<alpha, 1, mean),
           Chisq.fdr=apply(chisq_fdr<alpha, 1, mean),
           mc_fdr=apply(mc_fdr<alpha, 1, mean))
prop_loci_out_of_HWE_fdr             
```

### Check for linkage disequilibrium (LD)
For SNPs markers, I typically don’t know where on the genome they are located. The closer together two markers are on a chromosome, the more likely they are inherited together, which means that they don’t really provide independent information. Testing for linkage disequilibrium assesses this, for each pair of loci, by checking whether alleles of two loci are statistically associated. 
Here, I start with performing an overall test of linkage disequilibrium (the null hypothesis is that there is no linkage among the set of markers). Two indices are calculated and tested: an index of association (Ia; Brown et al. 1980) and a measure of correlation (rbarD; Agapow and Burt 2001), which is less biased (see URL above). The number of permutations is specified by ‘sample = 199.’
Overall, there is statistically significant association among the markers (p-value: prD = 0.005; also left figure). Recall that the power of a statistical test increases with sample size, and here we have n = 181, hence even a small effect may be statistically significant. Hence we look at effect size, i.e., the actual strength of the pairwise associations (right figure)

```{r LD}
ld <-poppr::ia(mastogenind0305, sample=199)
ld_pairs <- poppr::pair.ia(mastogenind0305)
ld_pairs
```

### Check for null alleles
See also Dakin and Avise (2004): http://www.nature.com/articles/6800545
One potential drawback for microsatellites as molecular markers is the presence of null alleles that fail to amplify, thus they couldn’t be detected in the PCR assays.
The function ‘null.all’ takes a genind object and returns a list with two components (‘homozygotes’ and ‘null.allele.freq’), and each of these is again a list. See ‘?null.all’ for details and choice of method.
List ‘homozygotes’:
1. homozygotes$observed: observed number of homozygotes for each allele at each locus
2. homozygotes$bootstrap: distribution of the expected number of homozygotes
3. homozygotes$probability.obs: probability of observing the number of homozygotes
Note: we are turning off warnings here (currently the code throws a warning for each sample, though results don’t seem to be affected).
```{r null allelles }
# Null alleles: depends on method! See help file.
null_alleles <- PopGenReport::null.all(mastogenind0305)
```

### 3. Assess genetic diversity
These measures are typically quantified per population.
#### Rarefied allelic richness
Both nominal sample size (number of mice per sampled) and valid sample size (e.g., for each locus, the number of mice with non-missing genetic data) vary between sites. Hence would expect the number of alleles found in a population to increase with the number of individuals genetyped
I ran  can check this by plotting the number of alleles against sample size. Here we create an object ‘Sum’ that contains the summary of the genind object, then we can access its elements by ‘$’ to plot what we need. The function ‘names’ lists the names of the elements, which reduced the guesswork.
```{r plotting summeries, fig.height=8, fig.width=10}
Sum <- summary(mastogenind0305)
names(Sum)
par(mar=c(5.5, 4.5,1,1))
barplot(Sum$pop.n.all, las=3,
       xlab = "", ylab = "Number of alleles")
plot(Sum$n.by.pop, Sum$pop.n.all, 
       xlab = "Sample size", ylab = "Number of alleles")
abline(lm(Sum$pop.n.all ~ Sum$n.by.pop), col = "red")

```

Hence we should not compare the number of alleles directly. Instead, we’ll use rarefied allelic richness (Ar).
By default, the function ‘allel.rich’ finds the lowest valid sample size across all populations and loci, and multiplies it by the ploidy level. The number is stored as ‘Richness$alleles.sampled’ (here: 3 individuals * 2 alleles = 6 alleles). Alternatively, this number can be set with the ‘min.alleles’ argument.
```{r richness report }
Richness <- PopGenReport::allel.rich(mastogenind0305, min.alleles = NULL)
Richness$alleles.sampled
```

Populations with more alleles are resampled to determine the average allelic richness among the minimum number of alleles. Here, this means that 6 alleles are sampled from each population, allelic richness is calculated, and the process is repeated many times to determine the average).
Let’s plot the results again. The barchart shows that there is considerable variation in genetic diversity among ponds. The scatterplot against sample size (here: for each population, the average number of valid alleles across loci) suggests that the variation is not related to sample size. The regression line (red) is almost horizontal.
Here we plot the average Ar across loci, so that the result does not depend on the number of loci used.
```{r Rarefied allelic richness }
par(mar=c(5.5, 4.5,1,1))
barplot(Richness$mean.richness, las=3, ylab="Rarefied allelic richness (Ar)")
plot(colMeans(Richness$pop.sizes), Richness$mean.richness,
     xlab="Valid sample size", 
     ylab="Rarefied allelic richness (Ar)")
abline(lm(Richness$mean.richness ~ colMeans(Richness$pop.sizes)), col="red")
```

#### observed and expected heterozygosity
Note: Writing the ‘genind’ summary into an object ‘Sum’ allows accessing its attributes by name.
Expected heterozygosity (here: Hexp) is the heterozygosity expected in a population under HWE, and observed heterozygosity (here: Hobs) is the observed number of heterozygotes at a locus divided by the total number of genotyped individuals. Here are the global values (pooled across all populations):
```{r He and Ho heterozygosity, fig.height=8, fig.width=10}
  par(mar=c(3, 4.5,1,1))
  barplot(Sum$Hexp, ylim=c(0,1), ylab="Expected heterozygosity")
  barplot(Sum$Hobs, ylim=c(0,1), ylab="Observed heterozygosity")
```

##### by locus and population
Here we use ‘seppop’ to split the genind object by population, then ‘sapply’ to apply function ‘summary’ to each population.
```{r heterozygoysity by pop, message=FALSE, warning=FALSE}
  Hobs <- t(sapply(seppop(mastogenind0305), function(ls) summary(ls)$Hobs))
  Hexp <- t(sapply(seppop(mastogenind0305), function(ls) summary(ls)$Hexp))
  {cat("Expected heterozygosity (Hexp):", "\n")
  round(Hexp, 2)
  cat("\n", "Observed heterozygosity (Hobs):", "\n")
  round(Hobs, 2)}
```

#### plotting heterozygoysity by pop
```{r plotting heterozygoysity by pop, fig.height=8, fig.width=10}
  par(mar=c(5.5, 4.5, 1, 1))
  Hobs.pop <- apply(Hobs, MARGIN = 1, FUN = mean)
  Hexp.pop <- apply(Hexp, 1, mean) 
  barplot(Hexp.pop, ylim=c(0,1), las=3, ylab="Expected heterozygosity")
  barplot(Hobs.pop, ylim=c(0,1), las=3, ylab="Observed heterozygosity")
```

#### create table with sitel-level genetic diversity measures
```{r}
masto_diversity <- data.frame(Pop = names(Hobs.pop),
                              n = Sum$n.by.pop,
                              Hobs = Hobs.pop,
                              Hexp = Hexp.pop,
                              Ar = Richness$mean.richness)
masto_diversity
```

## Filtering 
```{r pllotting barplot for complete data , fig.height=8, fig.width=10}
masto_locimiss_ = propTyped(mastogenind0305, by = "loc")
#mastogenind0305[which(masto_locimiss_ < 0.80)] # print loci with < 80% complete genotypes
## named numeric(0)
# Barplot
barplot(masto_locimiss_, ylim = c(0,1), ylab = "Complete genotypes (proportion)", xlab = "Locus", las = 2, cex.names = 0.7)
```

```{r}
indmiss_masto = propTyped(mastogenind0305, by = "ind")
indmiss_masto[ which(indmiss_masto < 0.70) ] # print individuals with < 80% complete genotypes
##     Ale04     Ale06     Ale08     Ale13     Ale15     Ale16     Ale19     Sin65 
## 0.4936709 0.5063291 0.5443038 0.5696203 0.4556962 0.5316456 0.4430380 0.7848101 
##     The2

summary(indmiss_masto)
```

### Check genotypes are unique
Check all individual genotypes are unique. Duplicated genotypes can result from unintentionally sampling the same individual twice or from sampling clones.
```{r}
# Print the number of multilocus genotypes
poppr::mlg(mastogenind0305)
```

### Identify duplicated genotypes.

```{r}
dups_masto = popprmlg.id(mastogenind0305)
for (i in dups_masto){ # for each element in the list object
  if (length(dups_masto[i]) > 1){ # if the length is greater than 1
    print(i) # print individuals that are duplicates
  }
}
```


### number of private alleles 
```{r}
poppr::private_alleles(mastogenind0305) %>% apply(MARGIN = 1, FUN = sum)
```

### mean allelic richness per site across all loci
```{r}
hierfstat::allelic.richness(hierfstat::genind2hierfstat(mastogenind0305))$Ar %>%
  apply(MARGIN = 2, FUN = mean) %>% 
  round(digits = 3)
```
### heterozygosity per site
```{r}
# Calculate basic stats using hierfstat
basic_stats_masto = hierfstat::basic.stats(mastogenind0305, diploid = TRUE)
```

#### mean observed heterozygosity per site
```{r}
Ho_masto = apply(basic_stats_masto$Ho, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
  round(digits = 2)
Ho_masto
```
#### mean expected heterozygosity per site
```{r}
He_masto = apply(basic_stats_masto$Hs, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
  round(digits = 2)
He_masto

```

#### inbreedinng coefficient Fis
```{r}
Fis_masto <- apply(basic_stats_masto$Fis, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
  round(digits = 3)
Fis_masto
```

#### visualise heterozygosity per site 
```{r fig.height=8, fig.width=10}
# Create a data.frame of site names, Ho and He and then convert to long format
Het_masto_df = data.frame(Site = names(Ho_masto), Ho = Ho_masto, He = He_masto) %>%
  reshape::melt(id.vars = "Site")
library(ggplot2)
# Custom theme for ggplot2
custom_theme = ggplot2::theme(
  axis.text.x = element_text(size = 12, angle = 45, vjust = 0.5),
  axis.text.y = element_text(size = 12),
  axis.title.y = element_text(size = 12),
  axis.title.x = element_blank(),
  axis.line.y = element_line(size = 0.25),
  legend.title = element_blank(),
  legend.text = element_text(size = 12),
  panel.grid = element_blank(),
  panel.background = element_blank(),
  plot.title = element_text(hjust = 0.5, size = 12,))
# Italic label
hetlab.o = expression(italic("H")[o])
hetlab.e = expression(italic("H")[e])

# Lobster heterozygosity barplot
ggplot2::ggplot(Het_masto_df, aes(x = Site, y = value, fill = variable)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.6), colour = "black") +
  scale_y_continuous(expand = c(0,0), limits = c(0,0.25))+
  scale_fill_manual(values = c("red", "#bdbdbd"), labels = c(hetlab.o, hetlab.e))+
  ylab("Heterozygosity")+
  #ggtitle("European lobster")+
  custom_theme
```
#### inbreeding coefficient (FIS)
Calculate mean FIS per site.
```{r}
apply(basic_stats_masto$Fis, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
  round(digits = 3)
```

#### FST, PCA & DAPC
##### FST
Compute pairwise FST (Weir & Cockerham 1984).
```{r}
# Compute pairwise Fsts
masto_fst = hierfstat::genet.dist(mastogenind0305, method = "WC84") %>% round(digits = 3)
masto_fst
```
#### visualise pairwise FST for mastomys
```{r fst heatmap, fig.height=10, fig.width=10}
# Desired order of labels
#lab_order = c("Ber","Brd","Pad","Vig","Sar17","Ale")
lab_order = c("Elangeni", "Shewula", "Matsapha", "Siteki", "Malandela", "Tabankulu")
# Change order of rows and cols
fst.mat = as.matrix(masto_fst)
fst.mat1 = fst.mat[lab_order, ]
fst.mat2 = fst.mat1[, lab_order]
# Create a data.frame
ind = which(upper.tri(fst.mat2), arr.ind = TRUE)
fst.df = data.frame(Site1 = dimnames(fst.mat2)[[2]][ind[,2]],
                    Site2 = dimnames(fst.mat2)[[1]][ind[,1]],
                    Fst = fst.mat2[ ind ])

# Keep the order of the levels in the data.frame for plotting 
fst.df$Site1 = factor(fst.df$Site1, levels = unique(fst.df$Site1))
fst.df$Site2 = factor(fst.df$Site2, levels = unique(fst.df$Site2))
# Convert minus values to zero
fst.df$Fst[fst.df$Fst < 0] = 0
# Print data.frame summary
fst.df %>% str
# Fst italic label
fst.label = expression(italic("F")[ST])
# Extract middle Fst value for gradient argument
mid = max(fst.df$Fst) / 2
# Plot heatmap
ggplot(data = fst.df, aes(x = Site1, y = Site2, fill = Fst))+
  geom_tile(colour = "black")+
  geom_text(aes(label = Fst), color="black", size = 3)+
  scale_fill_gradient2(low = "blue", mid = "pink", high = "red", midpoint = mid, name = fst.label, limits = c(0, max(fst.df$Fst)), breaks = c(0, 0.05, 0.10, 0.15))+
  scale_x_discrete(expand = c(0,0))+
  scale_y_discrete(expand = c(0,0), position = "right")+
  theme(axis.text = element_text(colour = "black", size = 12),
        axis.title = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        legend.position = "right",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12))
```

## PCA
Perform a PCA (principle components analysis) on the mastomys data set
```{r PCA, fig.height=10, fig.width=10}
# Replace missing data with the mean allele frequencies
x = tab(mastogenind0305, NA.method = "mean")
# Perform PCA
pca1 = dudi.pca(x, scannf = FALSE, scale = FALSE, nf = 3)
# Analyse how much percent of genetic variance is explained by each axis
percent = pca1$eig/sum(pca1$eig)*100
barplot(percent, ylab = "Genetic variance explained by eigenvectors (%)", ylim = c(0,12),
        names.arg = round(percent, 1))
```

### visualise PCA results
```{r visualise PCA results, fig.height=10, fig.width=10}
library(dplyr)
library(RColorBrewer)
# Create a data.frame containing individual coordinates
ind_coords = as.data.frame(pca1$li)
# Rename columns of dataframe
colnames(ind_coords) = c("Axis1","Axis2","Axis3")
# Add a column containing individuals
ind_coords$Ind = indNames(mastogenind0305)
# Add a column with the site IDs
ind_coords$Site = mastogenind0305$pop
# Calculate centroid (average) position for each population
centroid = aggregate(cbind(Axis1, Axis2, Axis3) ~ Site, data = ind_coords, FUN = mean)
# Add centroid coordinates to ind_coords dataframe
ind_coords = left_join(ind_coords, centroid, by = "Site", suffix = c("",".cen"))
# Define colour palette
cols = brewer.pal(nPop(mastogenind0305), "Set1")
# Custom x and y labels
xlab = paste("Axis 1 (", format(round(percent[1], 1), nsmall=1)," %)", sep="")
ylab = paste("Axis 2 (", format(round(percent[2], 1), nsmall=1)," %)", sep="")
# Custom theme for ggplot2
ggtheme = theme(axis.text.y = element_text(colour="black", size=12),
                axis.text.x = element_text(colour="black", size=12),
                axis.title = element_text(colour="black", size=12),
                panel.border = element_rect(colour="black", fill=NA, size=1),
                panel.background = element_blank(),
                plot.title = element_text(hjust=0.5, size=15))
# Scatter plot axis 1 vs. 2
ggplot(data = ind_coords, aes(x = Axis1, y = Axis2))+
  geom_hline(yintercept = 0)+
  geom_vline(xintercept = 0)+
  # spider segments
  geom_segment(aes(xend = Axis1.cen, yend = Axis2.cen, colour = Site), show.legend = FALSE)+
  # points
  geom_point(aes(fill = Site), shape = 21, size = 3, show.legend = FALSE)+
  # centroids
  geom_label(data = centroid, aes(label = Site, fill = Site), size = 4, show.legend = FALSE)+
  # colouring
  scale_fill_manual(values = cols)+
  scale_colour_manual(values = cols)+
  # custom labels
  labs(x = xlab, y = ylab)+
  ggtitle("Mastomys natalesnsis PCA")+
  # custom theme
  ggtheme
# Export plot
ggsave("~/Documents/Phd_dissetation/Mastomys_SNPs/output_plots/pca.png", width = 10, height = 8, dpi = 600)

```

### DAPC
Perform a DAPC (discriminant analysis of principal components) on the seafan data set.
```{r dapc, fig.height=8, fig.width=10}
# Perform cross validation to find the optimal number of PCs to retain in DAPC
set.seed(123)
x = tab(mastogenind0305, NA.method = "mean")
crossval = xvalDapc(x, mastogenind0305$pop, result = "groupMean", xval.plot = TRUE)
ggsave("~/Documents/Phd_dissetation/Mastomys_SNPs/output_plots/crossval.png", width = 10, height = 8, dpi = 300)
```

## Outlier SNPs
To illustrate importing VCF files and conducting OutFLANK outlier selection tests in R, we will use an American lobster SNP data set available from the Dryad Digital Repository.
Conduct outlier tests using OutFLANK
Conduct FST differentiation-based outlier tests on genind object using OutFLANK using a wrapper script from the dartR package.
```{r Outlier SNPs, fig.height=8, fig.width=10}
# Load packages
library(OutFLANK)
library(qvalue)
library(dartR)
# Run OutFLANK using dartR wrapper script
outflnk = gl.outflank(mastogenind0505, qthreshold = 0.05, plot = FALSE)
# Extract OutFLANK results
outflnk.df = outflnk$outflank$results
# Remove duplicated rows for each SNP locus
rowsToRemove = seq(1, nrow(outflnk.df), by = 2)
outflnk.df = outflnk.df[-rowsToRemove, ]
# Print number of outliers (TRUE)
outflnk.df$OutlierFlag %>% summary
# Extract outlier IDs
outlier_indexes = which(outflnk.df$OutlierFlag == TRUE)
outlierID = locNames(mastogenind0505)[outlier_indexes]
outlierID

# Convert Fsts <0 to zero
outflnk.df$FST[outflnk.df$FST < 0] = 0 

# Italic labels
fstlab = expression(italic("F")[ST])
hetlab = expression(italic("H")[e])

# Plot He versus Fst
ggplot(data = outflnk.df)+
  geom_point(aes(x = He, y = FST, colour = OutlierFlag))+
  scale_colour_manual(values = c("black","red"), labels = c("Neutral SNP","Outlier SNP"))+
  ggtitle("OutFLANK outlier test")+
  xlab(hetlab)+
  ylab(fstlab)+
  theme(legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5, size = 15, face = "bold"))
```










```{r}
 args(spca)
```

```{r}
mySpca <- spca(mastogenind0305, ask = FALSE, scannf = FALSE)


mySpca2 <- spca(obj, xy = mastogenind0505$other$, ask = FALSE, scannf = FALSE)
all.equal(mySpca, mySpca2
```









## Spatial Population Genetic Structure
```{r}
masto_coords  <- pop0305_data
masto_diversity <- as.data.frame(masto_diversity)

masto_ecogen <- ecogen(G = mastogenlight_df[,-c(mastogenlight_df$sample_id)], ploidy = 2, 
                       type = "codominant", sep = ":",
                       S = data.frame(mastogenlight_df[, mastogenlight_df$sample_id]))
Frogs.ecogen

Frogs.loci <- read.csv(system.file("extdata", "ralu_loci_allpops.csv", 
                                     package = "LandGenCourse"))




```






















## Population structure 
### 1. Perform Principal Components Analysis (PCA)
I start by perfoming ordination (Principal components analysis, or PCA) to examine population structure for the Nm = 2 data set.
The R command for PCA is fairly simple and fast
```{r pca with prcomp, message=FALSE, warning=FALSE}
pc = prcomp(genotypes_imp, scale = T)   
summary(pc)
pop_ids <- new_mastogenlight_df$pop[-1]
```

In order to visualize how the first two eigenvectors capture genotype variation, we will color each population
```{r plot eigenvectors, fig.height=8, fig.width=10}
par(mar=c(4,4,0.5,0.5))
plot(pc$x, pch = 19, cex = 2, col = rep(c("blue2", "orange"), each = 100))
```

```{r population structure summary, fig.height=8, fig.width=10}
par(mar=c(4,4,0.5,0.5))
coord <- cbind(sort(c(rnorm(84, -2, 1), rnorm(84, 2, 1))), runif(169))


coord <-rbind(c(new_mastogenlight_df$easting, new_mastogenlight_df$northing))


fit  <- fields::Krig(coord, pc$x[,1], m=1)
fields::surface(fit)
points(coord, pch = 19) 
```
This map predicts the value of the first principal component at each location in our study area. I observe that the study area is not partitioned into visible clusters from PC 1. I superimpose this on a study ar map later. 
```{r}
table((pc$x[,1] > 0) == (1:169 <= 86))
```
In this example, we found that 89 individual were not assigned to their island of origin. Well, these individuals might be migrants from the last generation. These results indicated that a very simple method based on principal component analysis can correctly describe spatial population genetic structure.

### Running populaton geentic structure with admixture model
```{r scree plot, fig.height=8, fig.width=10}
pops <- unique(new_mastogenlight_df$pop)
par(mar=c(4,4,2,0.5))
pcaS <- prcomp(genotypes_imp,center=T)
plot(pcaS$sdev^2 / sum(pcaS$sdev^2), xlab="PC",
     ylab="Fraction Variation Explained", main="Scree plot")
```
### Get % variance explained for first few PCs:
```{r}
perc <- round(100*(pcaS$sdev^2 / sum(pcaS$sdev^2))[1:10],2)
names(perc) <- apply(array(seq(1,10,1)), 1, function(x){paste0("PC", x)})
perc 
## PC1  PC2  PC3  PC4  PC5  PC6  PC7  PC8  PC9 PC10 
## 7.42 1.62 1.45 1.41 1.37 1.36 1.30 1.30 1.29 1.28 
```

### use the RColorBrewer package to select a color palette:
```{r pcs, fig.height=8, fig.width=10}
colors <- RColorBrewer::brewer.pal(9, "Paired") 
par(mfrow=c(2,2), mar=c(4,4,0.5,0.5))
plot(pcaS$x[,1:2], col=colors[factor(pop_ids)], pch=16,cex=1.2)
legend("topleft", legend=levels(factor(pop_ids)), 
       col=colors, pch=16, ncol=3, cex=0.8)
plot(pcaS$x[,2:3], col=colors[factor(pop_ids)], pch=16, cex=1.2)
plot(pcaS$x[,3:4], col=colors[factor(pop_ids)], pch=16, cex=1.2)
```
### Clustering with SNMF (similar to ‘STRUCTURE’)
Now I am are going to use a clustering method to examine population structure. There are many approaches, with various assumptions, and it is important to consider the underlying biology of your research organism (and your dataset size) before choosing an appropriate method.
Here, I will use sparse negative matrix factorization (SNMF) because it is fast to compute for large datasets and it approximates the results of the well-known STRUCTURE algorithm. Notably, it relaxes population genetic assumptions such as Hardy-Weinberg proportions, so it may not converge on the same results as other programs.
I can use SNMF to estimate the number of genetic clusters (K) among our sampled populations. However, this may take a long time. If you want to run the analysis, un-comment the lines by removing the ‘#’ symbol at the beginning of each line.
I use SNMF’s cross-entropy criterion to infer the best estimate of K. The lower the cross-entropy, the better our model accounts for population structure. Sometimes cross-entropy continues to decline, so we might choose K where cross entropy first decreases the most.
```{r population clustering, fig.height=8, fig.width=10}
masto.geno <- genind2genpop(mastogenind0305)
masto.geno
input.file <- 'masto.geno'
K=6
masto_snmf = LEA::snmf( "masto.geno" , K = K, alpha = 100, project = "new", entropy = F)





obj.snmf = snmf("secondary_contact.geno", K = 1:8,  ploidy = 2, entropy = T,
                alpha = 100, project = "new")

plot(obj.snmf, col = "blue4", cex = 1.4, pch = 19)
K=4
snmf = LEA::snmf(system.file("extdata", "stickleback.geno", package = "LandGenCourseData"), 
                 K = K, alpha = 100, project = "new")


```


















### principal component analyses 
```{r pca1}
masto_pca0305 <- glPca(mastogenlight0305, nf = 2) # nf indicates number of principal components to retain
```
### converting the pca scores to a data frame
```{r pca eigenvalues barplot, fig.height=8, fig.width=10}
masto_pca_scores0305 <- as.data.frame(masto_pca0305$scores)
masto_pca_scores0305$pop <- pop(mastogenlight0305)
masto_pca_scores0305$landuse <- pop0305_data$landuse
masto_pca_scores0305$region <- pop0305_data$region
barplot(100*masto_pca0305$eig/sum(masto_pca0305$eig), col = heat.colors(50), main="PCA Eigenvalues")
```
#### plotting PCA
```{r pca plot, fig.height=8, fig.width=10}
masto_pca0305_plot <- ggplot(masto_pca_scores0305, aes(x=PC1, y=PC2, colour=pop, shape = landuse))+ 
  geom_point(size=2) + 
  stat_ellipse(level = 0.95, size = 1)+
  scale_color_manual(values = pop_pallete) + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) +
  theme_bw() +
  labs(y = 'PC1', x = 'PC2', color = "Population", shape = "Land-use type") +
  theme(axis.ticks.length = unit(-0.05, "cm" ), 
        axis.text.x = element_text(margin = unit(c(0.5,0.5,0.5,0.5), "cm"), size = 12, colour = "black"), 
        axis.text.y = element_text(margin = unit(c(0.5,0.5,0.5,0.5), "cm"), size = 12, colour = "black"),
        text = element_text(size = 12, family= 'Arial'), 
        legend.position ="right", 
        legend.title = element_text(size = 12, colour = "black"), 
        legend.text = element_text( size =12, colour = "black"))
masto_pca0305_plot
```
## Converting the fileee to differnt  formats
```{r vcf to genlight}


mastogenlight_df <- as.data.frame(mastogenlight0305)
mastogenind0305 <- df2genind(mastogenlight_df, ploidy = 2, ncode = 2)
```



## Discriminant component analyses
```{r dapc, fig.height=8, fig.width=10}
masto_dapc0305 <- dapc(mastogenlight0305, n.pca = 3, n.da = 2)

masto_dapc0305_plot1<- scatter(masto_dapc0305, col = pop_pallete , cex = 2, 
                               legend = TRUE,clabel = F, 
                               posi.leg = "bottomleft", scree.pca = TRUE,
        posi.pca = "topleft", cleg = 0.75)
compoplot(masto_dapc0305, col = pop_pallete, posi = 'top')

ggsave(plot = masto_dapc0305_plot1, filename = "~/Documents/Phd_dissetation/Mastomys_SNPs/output_plots/pop_pca_plot1", dpi = 600)
#ggsave(plot = pop_structure, filename = "~/Documents/Phd_dissetation/Mastomys_SNPs/output_plots/structue_pca_plot", dpi = 600)

```

### dapc plot  with ggplot
```{r dapc with ggplot, fig.height=10, fig.width=10}
dapc0305_results <- as.data.frame(masto_dapc0305$posterior)
dapc0305_results$pop <- pop(mastogenlight0305)
dapc0305_results$indNames <- rownames(dapc0305_results)
dapc0305_results <- melt(dapc0305_results)
colnames(dapc0305_results) <- c("Original_Pop","Sample","Assigned_Pop","Posterior_membership_probability")
masto_dapc0305_plot <- ggplot(dapc0305_results, aes(x=Sample, y=Posterior_membership_probability, fill=Assigned_Pop)) +
  geom_bar(stat = "identity", position = "stack", na.rm = TRUE) + 
  scale_color_manual(values = pop_pallete) +
  labs(x = "Rodents", y = "Posterior membership probability", fill = "Assigned Population") +
  facet_wrap(~ Original_Pop, scales = "free") +
  theme_bw()+ 
  theme(panel.background = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_text(size = 12, colour = "black"),
        legend.title = element_text(size = 12, colour = "black"), 
        legend.text = element_text(size = 12, colour = "black"),
        text = element_text(size = 12, family= 'Arial', colour = "black"))
masto_dapc0305_plot
ggsave(plot = masto_dapc0305_plot, filename = "~/Documents/Phd_dissetation/Mastomys_SNPs/output_plots/dapc_landuse.png", dpi = 600)
```

## Spatial genetic structure  
```{r}
genotypes <- mastogenlight_df[, 2:ncol(mastogenlight_df)]
dim(genotypes)
mastogenlight_df <-tibble::rownames_to_column(mastogenlight_df, "sample_id") 
new_mastogenlight_df <- merge(mastogenlight_df, pop0305_data, by = "sample_id")
```

### PCA
I start this analyses with using ordination (Principal components analysis, or PCA) to examine population structure for the Nm = 2 data set
```{r}
pc = prcomp(genotypes, scale =T)   
par(mar=c(4,4,0.5,0.5))
plot(pc$x, pch = 19, cex = 2, col = rep(c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")))
```


















## Detecting adaptation 
```{r detecting adaptation }
mastogenlight_df[is.na(mastogenlight_df)] <- 0 
genotypes <- mastogenlight_df[, 2:ncol(mastogenlight_df)]
dim(genotypes)
mastogenlight_df <-tibble::rownames_to_column(mastogenlight_df, "sample_id") 
new_mastogenlight_df <- merge(mastogenlight_df, pop0305_data, by = "sample_id")
```
The dataset have 169 individuals (rows) genotyped at 19,356 SNPs (columns).
Both LFMM and RDA require complete data frames (i.e., no missing genetic data). For this example, we’ll use a simple approach to imputing missing genotype values: we will impute using the most common genotype at each SNP across all individuals.

```{r}
sum(is.na(genotypes)) ## 2.,987 NAs in the matrix (~3% missing data)
```

```{r removing Na}
genotypes_imp <- apply(genotypes, 2, function(x) replace(x, is.na(x), as.numeric(names(which.max(table(x))))))
sum(is.na(genotypes_imp)) # No NAs
```
I could also use this imputation approach within ecotypes (rather than across all individuals). Other promising imputation methods for species lacking a reference genome include: using ancestry values from snmf in the LEA package (Frichot & Francois 2015), and the program LinkImpute (Money et al., 2015).

### Import the environmental data
The original data set comes with 3 predictors (rainfall, elevation and temperature), but many of them are highly correlated, which can cause problems for regression-based methods like LFMM and RDA. I conducted variable reduction using the |0.7| “rule of thumb” (Dormann et al., 2013) and an ecological interpretation of the relevance of possible predictors. Can you double check the correlations among the variables?
For more information on the rationale for variable reduction, see the full RDA vignette.
```{r}
##enviromental varriables
env <- new_mastogenlight_df %>%
  select(sample_id, mean_min_temp,mean_max_temp, 
         mean_rainfall,elevation,  landuse, pop)
str(env) 
sum(is.na(env))
env[is.na(env)] <- 0

# Look at the structure of the data frame
```

```{r}
env$sample_id <- as.character(env$sample_id) # Make individual names characters (not factors)
# Confirm that genotypes and environmental data are in the same order
identical(rownames(genotypes_imp), env[,1]) ## this is tru so we are good to go 
```
Now I am  subsetting just the environmental predictors & shorten their names:
```{r renaming columns in  env}
pred <- env[,2:5]
colnames(pred) <- c("AMXT","AMNT","AP","ELEV")
```

For the univariate LFMM test, I could run a separate set of tests for each of these four predictors; this would be a test for each of the 19,000 SNPs with each predictor = 304, 000 tests. Instead, for LFMM, I perform a PCA on the environmental predictors and use the first principal component (PC) as a synthetic predictor. This will reduce our ability to interpret the output, since the PC predictor will be a linear combination of the original four variables, but it will reduce the number of corrections needed for multiple tests. Your decision of how to handle multiple predictors for a univarate GEA test will depend on the study goals and characteristics of the data set.
There are many ways to run PCA in R; i will use the rda function in vegan (Oksanen et al., 2016). I  center and scale the predictors (scale=T), since they’re in different units. We’ll then determine the proportion of the environmental variance explained by each PC axis & investigate how the original predictors correlate with the first PC axis.

```{r prediction pca}
pred_pca <- rda(pred, scale=T)
summary(pred_pca)$cont
```
```{r scree plot}
screeplot(pred_pca, main = "Screeplot: Eigenvalues of M.natalesnis Predictor Variables")
```
```{r pc axis corralation }
## c.rrelations between the PC axis and predictors:
round(scores(pred_pca, choices=1:4, display="species", scaling=0), digits=3)
```
50% of the variance in the predictors is explained by the first PC axis, and 36% by the second axis. I could follow up with an LFMM model using the second axis as a predictor. The strongest correlations with PC1 are annual mean precipitation (AP : 58%), Annual Mean Max Temperature (AMXT : 56%).

now lest store the synthetic PC axis predictor as pred.PC1 for use in LFMM.

```{r prediction pc1}
pred_PC1 <- scores(pred_pca, choices=1, display="sites", scaling=0)
```


### Latent Factor Mixed Models (LFMM): a univariate GEA
LFMM is a univariate test, which means that it builds a model for each SNP and each predictor variable. In this case, we will run 19,000 SNPs x 1 synthetic predictor = 19,000 separate LFMM tests.
### Determine K
LFMM requires an estimate of the number of populations in the data (K). To determine the most likely value of K, we’ll use PCA, noting that there are many different approaches for determining “K” from genetic data (more below). It is also reasonable to run LFMM with different values of K, if there is uncertainty.
We’ll use a broken stick criterion to determine K. The broken stick stopping rule states that principal components should be retained as long as observed eigenvalues are higher than corresponding random broken stick components.
For example, if we reran the environmental PCA screeplot from above with a broken stick criterion:
```{r}
screeplot(pred_pca, main = "Screeplot of M.natalensis Predictor Variables with Broken Stick", bstick=TRUE, type="barplot")
```
Here I see that PC1 and PC2 explain more than the random broken stick components, while PC3 + do not. If this were genomic data, and we were determining a value of K using this approach, we’d set K = 3.

Now I am running a PCA with the genommic data and plot the eigenvalues with the broken stick criterion:
```{r pca on genotyps }
gen_pca <- rda(genotypes_imp, scale=T)
screeplot(gen_pca, main = "Screeplot of M.natalesis Genetic Data with Broken Stick", bstick=TRUE, type="barplot")
```
For the genomic data, I can see that none of the PCs have eigenvalues greater than random (greater than the broken stick values in red). This effectively means that K=1 for the Mastomys data set, based on a PCA assessment. This does not mean there isn’t genetic structure in the data; it just means the structure isn’t particularly strong and/or easily partitioned into discrete groupings.
For now, we’ll use K=3
```{r defining K }
K <- 3
```

### Run LFMM
LFMM is a regression model that includes unobserved variables (latent factors, set with “K”) that correct the model for confounding effects, such as population structure. The latent factors are estimated simultaneously with the environmental and response variables, which can help improve power when environment and demography are correlated.
The previous version of LFMM (v1.5, implemented in the LEA package) uses an MCMC (Markov chain Monte Carlo) algorithm to identify GEAs while correcting for confounding. MCMC made it (very!) time-intensive for large data sets. LFMM v.2 computes LFMMs for GEA using a least-squares estimation method that is substantially faster than v1.5 (Caye et al., 2019). There are two penalty approaches: ridge and lasso. We’ll use ridge today (see ?lfmm_ridge); see Jumentier et al. (2020) for more information on the ridge vs. lasso penalties.
```{r}
masto0305_lfmm <- lfmm_ridge(Y=genotypes_imp, X=pred_PC1, K=K) ## c.ange K as you see fit
```
That was fast! As you’ll see, post-processing these results is what takes up most of our time and effort…

### Identify LFMM candidates using False Discovery Rate
Next, post-process the model output. We will move fast here; I strongly recommend reading “Controlling false discoveries in genome scans for selection” (Francois et al., 2016) if you will be running these post-processing steps on your own data! Decisions made here can dramatically impact the candidate markers you identify.
The steps for post-processing are:
1. Look at the genomic inflation factor (GIF), which gives us a sense for how well the model has accounted for confounding factors in the data.
2. Plot the p-values to see how application of the GIF influences the p-value distribution.
3. Modify the GIF (if needed) and re-plot the p-values to identify the best possible fit to the “ideal” p-value distribution.
4. Apply a False Discovery Rate control method to the p-values by converting to q-values.
5. Identify candidates as those below a given FDR threshold.
The False Discovery Rate is the expected proportion of false positives among the list of positive tests (see Storey and Tibshirani, 2003).
An essential point to understand here is that the FDR is predicated on the “ideal” p-value distribution (flat with a peak at 0, see Francois et al. 2016).For example, an FDR threshold of 0.10 applied to a dataset with an ideal p-value distribution would produce 10% false positives (aka false discoveries) among the set of positive tests. However, if the p-value distribution deviates from the ideal, this same FDR threshold of 0.10 would produce more or fewer false discoveries among the set of postive tests, depending on the skew in the p-value distribution.
So remember: having an actual FDR that is in accordance with the nominal threshold you set is completely dependent on the p-values used.
The lfmm package has a nice built-in function to calculate test statistics for the predictor(s), see 
```{r GIF-calibrated scores and p-values}
masto0305_pv <- lfmm_test(Y=genotypes_imp, X=pred_PC1, lfmm=masto0305_lfmm, calibrate="gif")
names(masto0305_pv) # this object includes raw z-scores and p-values, as well as GIF-calibrated scores and p-values
```

#### looking  at the genomic inflation factor (GIF):
```{r}
masto0305_pv$gif

```
An appropriately calibrated set of tests will have a GIF of around 1. The elevated GIF indicates that the results may be overly liberal in identifying candidate SNPs. If the GIF is less than one, the test may be too conservative.
NOTE: Changing the value of K influences the GIF, so additional tests using the “best” value of K +/- 1 may be needed in some cases. See Francois et al. (2016) for more details.
Let’s look at how application of the GIF to the p-values impacts the p-value distribution:
```{r the p-value distribution}
hist(masto0305_pv$pvalue[,1], main="Unadjusted p-values")        
hist(masto0305_pv$calibrated.pvalue[,1], main="GIF-adjusted p-values")
```
I want to see a relatively flat histogram (most loci not under selection) with a peak near zero, indicating candidate adaptive markers. We see a very large peak with the unadjusted p-values, and a much smaller peak with the GIF-adjusted p-values (note differences in the scale of the y-axis).
Note that you can choose a different GIF and readjust the p-values to get a “better” histogram distribution (that is, a distribution that conforms best with what is expected under a well-calibrated set of models, see Francois et al, 2016). This process is subjective and can be difficult with empirical data sets, especially those with an IBD signature, such as these wolf data. Remember, you can also change the value of K in your lfmm models and see how this impacts the GIF.
Below I’ll show you how to manually adjust the GIF correction factor:
```{r GIF correction factor}
# Let's change the GIF and readjust the p-values:
zscore <- masto0305_pv$score[,1]   # zscores for first predictor, we only have one in our case...
gif <- masto0305_pv$gif[1]      ## d.fault GIF for this predictor
```


```{r}
new_gif1 <- 1.0               ## c.oose your new GIF
# Manual adjustment of the p-values:
adj_pv1 <- pchisq(zscore^2/new_gif1, df=1, lower = FALSE)
```

```{r Plot the p-value histograms:}
hist(masto0305_pv$pvalue[,1], main="Unadjusted p-values")        
hist(masto0305_pv$calibrated.pvalue[,1], main="GIF-adjusted p-values (GIF=1.3)")
hist(adj_pv1, main="REadjusted p-values (GIF=1.0)")
```
For now, I stick with the default GIF calculated by the lfmm package, though it looks like the application of the GIF may be a bit conservative (e.g. it is compressing the peak at 0).
Finally, I convert the adjusted p-values to q-values. q-values provide a measure of each SNP’s significance, automatically taking into account the fact that thousands are simultaneously being tested. We can then use an FDR threshold to control the number of false positive detections (given that our p-value distribution is “well-behaved”).

```{r}
masto0305_qv <- qvalue(masto0305_pv$calibrated.pvalue)$qvalues
length(which(masto0305_qv < 0.1)) ## h.w many SNPs have an FDR < 10%?
```

```{r}
masto_FDR_1 <- colnames(genotypes_imp)[which(masto0305_qv < 0.1)] ## identify which SNPs these are
```
Using K=3, the default GIF correction, and an FDR threshold of 0.10, we did not detect candidate SNPs under selection in response to our PC1 environmental predictor. What changes could we make to have a less conservative test?
### 1. Redundancy Analysis (RDA): a multivariate GEA
### Run RDA
RDA is a multivariate ordination technique that can analyze many loci and environmental predictors simultaneously. For this reason, we can input all of the SNPs and environmental predictors at once, with no need to correct for multiple tests. RDA determines how groups of loci covary in response to the multivariate environment, and can better detect processes that result in weak, multilocus molecular signatures relative to univariate tests (Rellstab et al., 2015; Forester et al., 2018).
RDA can be used on both individual and population-based sampling designs. The distinction between the two may not be straightforward in all cases. A simple guideline would be to use an individual-based framework when you have individual coordinates for most of your samples, and the resolution of your environmental data would allow for a sampling of environmental conditions across the site/study area. For population-level data, you would input the genetic data as allele frequencies within demes.
The code to run the RDA is simple. However, I highly recommend reading Borcard et al. (2011) for details on the implementation and interpretation of RDA models and the objects created by vegan. RDA runs relatively quickly on most data sets, though you may need a high memory node on a cluster for very large data sets (i.e., millions of SNPs).

```{r redandecy analyses }
masto_rda <- rda(genotypes_imp ~ ., data=pred, scale=T)
masto_rda
```
First, note that we will have as many constrained (“RDA”) axes as we have predictors in the model. All residual variance is then modeled by PCA (the unconstrained “PC” axes). The proportion of the variance explained by the environmental predictors is given under the “Proportion” column for “Constrained”; this is equivalent to the R2 of a multiple regression. Just like in multiple regression, this R2 will be biased and should be adjusted based on the number of predictors. We can calculate the adjusted R2 using:

```{r RsquaredAdjusted}
RsquareAdj(masto_rda)
```
Our constrained ordination explains about 0.4% of the variation; this low explanatory power is not surprising given that we expect that most of the SNPs in our dataset will not show a relationship with the environmental predictors (e.g., most SNPs will be neutral).
The eigenvalues for the constrained axes reflect the variance explained by each canonical axis:
```{r rda summarry}
summary(masto_rda)$concont
```
We can visualize this information using a screeplot of the canonical eigenvalues by calling screeplot:
```{r screeplot visualization}
screeplot(masto_rda)
```
Here, we can see that the first three constrained axes explain most of the variance. The screeplot provides an informal (and quick) way to determine how many constrained axes to include when we search for candidate SNPs (below). We could start by investigating RDA axes that explain the most variance (excluding those after the “drop off” point in the screeplot.)
You can run a formal test of statistical significance of each constrained axis using: anova.cca(wolf.rda, by="axis"). We can assess both the full model and each constrained axis using F-statistics (Legendre et al, 2010). The null hypothesis is that no linear relationship exists between the SNP data and the environmental predictors. See ?anova.cca for more details and options. The screeplot and a formal test (by axis) are both reasonable approaches for determining which RDA axes to assess for candidate SNPs.
The permutation process to test the signficiance of each axis takes a while (up to a few hours on large data sets), so we’ll just use the screeplot for a first assessment. If we did run the formal test, we would find that the first three constrained axes are significant (p = 0.001); constrained axis 4 has a p-value of 0.080, while axes 5-8 have p-values > 0.850. This corresponds with our evaluation of the screeplot, above.

Finally, vegan has a simple function for checking Variance Inflation Factors for the predictor variables used in the model. This helps identify redundant predictors:

```{r Variance Inflation Factors}
vif.cca(masto_rda)
```
All values are below beside AMXT and AP, are above 10 , which indicates that multicollinearity among these predictors shouldn’t be a problem (Zuur et al., 2010).
Let’s make a quick plot of the RDA output using the default plotting in vegan:
```{r RDA output plot}
plot(masto_rda, scaling=3)
plot(masto_rda, choices = c(1, 3), scaling=3) ## d.fault is axes 1 and 2
```
Here, the SNPs are in red (in the center of each plot), and the individuals are the black circles. The blue vectors are the environmental predictors. The relative arrangement of these items in the ordination space reflects their relationship with the ordination axes, which are linear combinations of the predictor variables.
See the full RDA vignette for details on how to make more informative (and prettier!) RDA plots for this data set. For example, we could more clearly visualize the identified candidate loci in the ordination space and see how they are linked to the environmental predictors. We could also use RDA to investigate how wolf ecotypes (based on individual genotypes) are distributed in relation to the environmental predictors (Forester et al., 2018, Figures 9 & 10).

#### Making the plot pretty 
Let’s make some more informative plots. We’ll color the individual points based on their ecotype, which we can find in the env data set
```{r  Making the RDA plot pretty }
#unique(pop0305_data$pop)
levels(env$pop) <- c("Elangeni","Malandela","Matsapha","Shewula","Siteki","Tabankulu")
eco <- env$pop
bg <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3","#33a02c","#e31a1c") # 6 nice colors for our ecotypes

## This time, we’ll set the plots up and add each component in separately:
# axes 1 & 2

plot(masto_rda, type="n", scaling=3)
points(masto_rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(masto_rda, display="sites", pch=21, cex=1.3, scaling=3, bg=bg[eco]) # the wolves
text(masto_rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(eco), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)

# axes 1 & 3
plot(masto_rda, type="points", scaling=3, choices=c(1,3)) +
points(masto_rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3)) +
points(wolf.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[eco], choices=c(1,3)) + 
text(wolf.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))+ 
legend("topleft", legend=levels(eco), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

Now that the individuals are color coded, we can identify some interesting relationships. Starting with the plot of axes 1 and 2, note that individual genotypes from wet and temperate British Columbia (green) are positively related to high annual precipitation (AP) and low temperature seasonality (sdT). By contrast, Artic and High Arctic individuals are characterized by small mean diurnal temperature range (MDR), low annual mean temperature (AMT), lower levels of tree cover (Tree) and NDVI (a measure of vegetation greenness), and are found at lower elevation. Atlantic Forest and Western Forest individuals load more strongly on RDA axis 3, showing weak and strong precipitation seasonality (cvP) respectively, consistent with continental-scale climate in these regions.

### Identify candidate SNPs involved in local adaptation
We’ll use the loadings of the SNPs in the ordination space to determine which SNPs are candidates for local adaptation. The SNP loadings are stored as species in the RDA object. We’ll extract the SNP loadings from the three significant constrained axes:
```{r loading rrda}
load_rda <- scores(masto_rda, choices=c(1:3), display="species")  # Species scores for the first three constrained axes
```
If we look at histograms of the loadings on each RDA axis, we can see their (relatively normal) distributions. SNPs loading at the center of the distribution are not showing a relationship with the environmental predictors; those loading in the tails are, and are more likely to be under selection as a function of those predictors (or some other predictor correlated with them).
```{r}
hist(load_rda[,1], main="Loadings on RDA1")
hist(load_rda[,2], main="Loadings on RDA2")
hist(load_rda[,3], main="Loadings on RDA3")
```

I’ve written a simple function to identify SNPs that load in the tails of these distributions. We’ll start with a 3 standard deviation cutoff (two-tailed p-value = 0.0027). As with all cutoffs, this can be modified to reflect the goals of the analysis and our tolerance for true positives vs. false positives. For example, if you needed to be very conservative and only identify those loci under very strong selection (i.e., minimize false positive rates), you could increase the number of standard deviations to 3.5 (two-tailed p-value = 0.0005). This would also increase the false negative rate. If you were less concerned with false positives, and more concerned with identifying as many potential candidate loci as possible (including those that may be under weaker selection), you might choose a 2.5 standard deviation cutoff (two-tailed p-value = 0.012).
I define the function here as outliers, where x is the vector of loadings and z is the number of standard deviations to use:

```{r}
outliers <- function(x,z){
  lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading     
  x[x < lims[1] | x > lims[2]]               # locus names in these tails
}
```

Now let’s apply it to each significant constrained axis:
```{r}
cand1 <- outliers(load_rda[,1],3) # 77
cand2 <- outliers(load_rda[,2],3) # 26
cand3 <- outliers(load_rda[,3],3) # 94
ncand <- length(cand1) + length(cand2) + length(cand3)
ncand
```
We have 38 candidates on axis 1, 69 on axis 2, and 34 on axis 3, for a total of 141 candidate SNPs (note that the full wolf data set produces 604 candidates).
Next, we’ll organize our results by making one data frame with the axis, SNP name, loading, & correlation with each predictor:

```{r}
ncand <- ncand[!duplicated(ncand)] ## 1.4 unique candidates 
```
Let’s see where these candidate SNPs are in the ordination space. We’ll zoom the plot in to just the SNPs, and color code candidate SNPs in red:


```{r}
# Set up the color scheme for plotting:
bgcol  <- ifelse(colnames(genotypes_imp) %in% ncand, 'gray32', '#00000000')
snpcol <- ifelse(colnames(genotypes_imp) %in% ncand, 'red', '#00000000')
## a.es 1 & 2 - zooming in to just the SNPs here...
plot(masto_rda, type="n", scaling = 3, xlim = c(-1,1), ylim = c(-1,1), main = "Mastomys RDA, axes 1 and 2")
points(masto_rda, display ="species", pch=21, cex=1, col="gray32", bg='#f1eef6', scaling=3)
points(masto_rda, display ="species", pch=21, cex=1, col=snpcol, bg=bgcol, scaling=3)
text(masto_rda, scaling=3, display="bp", col="#0868ac", cex=1)

## a.es 2 & 3
plot(masto_rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1), choices=c(2,3), main="Mastomys RDA, axes 2 and 3")
points(masto_rda, display="species", pch=21, cex=1, col="gray32", bg='#f1eef6', scaling=3, choices=c(2,3))
points(masto_rda, display="species", pch=21, cex=1, col=bgcol, bg=snpcol, scaling=3, choices=c(2,3))
text(masto_rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(2,3))

```

```{r}
intersetcor(masto_rda)[,1:3]
```
Generally, candidate SNPs on axis 1 represent multilocus sets of SNP genotypes associated most strongly with annual mean temperature and annual precipitation; SNPs on axis 2 represent genotypes associated with mean diurnal range; and SNPs on axis 3 represent genotypes associated with precipitation seasonality. See the full RDA vignette for additional investigation of candidate SNPs.



























### 2. Outleir loci analyses 
###  filtering by rremoving  samples with >80% missing data 
```{r filtering, fig.height=8, fig.width=10}
mastoVCF0305@gt <- mastoVCF0305@gt[, c(TRUE, missing_data < 0.80)]
hist(missing_data, col = "#8DD3C7", xlab = "Missingness (%)")
mastoVCF0305
#all samples have some level of missing loci. the samples with >70% missing data will be removed below as an initial step
```
### 1. Outlier loci  under  selection using  with PCAdapt 
```{r subsettting genotypes}
mastogenlight_df[is.na(mastogenlight_df)] <- 0 
genotypes <- mastogenlight_df[, 2:ncol(mastogenlight_df)]
dim(genotypes)
mastogenlight_df <-tibble::rownames_to_column(mastogenlight_df, "sample_id") 
new_mastogenlight_df <- merge(mastogenlight_df, pop0305_data, by = "sample_id")
```
### making a PCAdapt pcadapt_class object
```{r making a pcadapt object, fig.height=10, fig.width=10}
# pcadapt_class with the read.pcadapt() function.
pca_genotype <- read.pcadapt(t(genotypes))
K <- 10
x <- pcadapt(pca_genotype, K = K)
plot(x, option = "screeplot") 
```

```{r}

plot(x, option = "scores", pop = new_mastogenlight_df$pop) 
plot(x, option = "manhattan")
plot(x, option = "qqplot", threshold = 0.1)
plot(x, option = "stat.distribution") # Distribution of Mahalanobis distances.
```
### Number of outlierspcadapt
```{r number of outliers pcadapt}
qval <- qvalue(x$pvalues)$qvalues
alpha <- 0.1
outliers_pcadapt <- which(qval < alpha)
print(outliers_pcadapt)
length(outliers_pcadapt)
```
#### Using a more stringent treshehold to detect outleirs 
```{r a more strigent alpha }
alpha <- 0.05  # use of a more stringent threshold to detect outliers
outliers <- which(qval < alpha)
print(outliers)
length(outliers)
```

```{r}
mastogenlight_df$pop <- pop(mastogenlight0305)
```
### 3. Loci under slection with OUTfLAnk 
```{r}
ind <- paste ("pop", new_mastogenlight_df$pop)# vector with the name of population
locinames <- as.character(seq(ncol(genotypes))) # vector with the name of loci
FstDataFrame <- MakeDiploidFSTMat(genotypes, locinames, ind)
```


```{r}
plot(FstDataFrame$FST, FstDataFrame$FSTNoCorr, xlim = c(-0.01,0.3), 
     ylim = c(-0.01, 0.3), pch = 20) +
  abline(0, 1) # Checking the effect of sample size on Fst since FSTCoCorr will be used in the follow
hist(FstDataFrame$FSTNoCorr)
```

```{r}
OF <- OutFLANK(FstDataFrame, NumberOfSamples=169, qthreshold = 0.05, 
               RightTrimFraction = 0.05)
# Plot the ditribution of Fst with the chi squared distribution
OutFLANKResultsPlotter(OF, withOutliers = TRUE, NoCorr = TRUE, Hmin = 0.1, 
                       binwidth = 0.005, Zoom = FALSE, RightZoomFraction = 0.05, 
                       titletext = NULL)
```
```{r}
outliers_OF <- OF$results$LocusName[OF$results$OutlierFlag == TRUE]
print(outliers_OF)
```

## Spatial statistics 
```{r}

Frogs.coords <- read.csv(system.file("extdata", "ralu_coords_allpops.csv", 
                                     package = "LandGenCourse"))
Frogs.diversity <- read.csv(system.file("extdata", "Frogs_diversity_allpops.csv", 
                                     package = "LandGenCourse"))
Frogs.loci <- read.csv(system.file("extdata", "ralu_loci_allpops.csv", 
                                     package = "LandGenCourse"))


masto0305_coords



```




















